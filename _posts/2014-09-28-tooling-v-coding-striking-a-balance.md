---
layout: post
title: "Tooling v. Coding: Striking a Balance"
---

Programmers must strike a delicate balance between expertise in tooling and expertise in writing code. Having lots of one and not enough of the other can result in large drops in efficiency. 

### Learn your tools

Here at Vanderbilt, I see many students struggle with the simple tools we use in our third programming course: SVN, VirtualBox, Vim/Emacs, and the command line. Generally, these students are fully capable programmers, but their lack of experience with basic tools of the trade makes them hopelessly inefficient. Granted, learning all of these tools at the same time _in addition_ to struggling with advanced C++ concepts must certainly be overwhelming. 

### Got code?

As someone who has always loved configuring tools, I unfortunately spent a significant portion of my career on the other side of the spectrum. My tools were well configured, I could navigate Emacs with ease, and with a few simple bash commands I could grep in a matter of seconds what would otherwise have taken hours to find. My programming skills, however, were lacking.

This summer I interned for [Nacho Cove](http://nachocove.com/), a start up that is dedicated to improving corporate email on mobile. The engineers at Nacho Cove, many of whom I had worked with previously at [Nukona](http://www.symantec.com/page.jsp?id=nukona&header=0&depthpath=0), were exceptionally experienced programmers who were able to make the most of the tools available to them without being distracted from the ultimate goal: writing code and producing a product.

During my internship, I realized something that should have been obvious to me all along: Choose your tools wisely, stick with them, and start writing code. After my very first week at the company, I already felt that my programming abilities had improved dramatically. Spending time writing code, and a lot of it, is the only way to become a better programmer. 

This semester, my goal is to spend a little less time in my .vimrc and .tmux.conf and a little more time in [SICP](http://mitpress.mit.edu/sicp/) and [Learn You a Haskell](http://learnyouahaskell.com/).
